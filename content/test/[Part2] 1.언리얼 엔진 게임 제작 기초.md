---
sticker: emoji//1f916
title: "[Part2] 1.언리얼 엔진 게임 제작 기초"
---

# 언리얼 게임 프레임웍
---
## 게임 콘텐츠의 구조
---
- 게임 제작을 위해 언리얼 엔진은 자체적으로 설계한 프레임웍을 제공함
- 이를 게임 플레이 프레임웍(Gameplay Framework)이라고 부름
- 언리얼 게임 프레임웍의 각 구성 요소를 파악하고, 이를 확장하면서 게임을 제작하는 것을 권장
![700](https://i.imgur.com/9rkud72.png)


## 1강 예제 게임 콘텐츠의 구성
---
[🔗이번 강의 준비물](https://github.com/ideugu/UnrealProgrammingPart2/tree/1_1)
이번 강의의 프로젝트는 아래 사진의 파란색 프레임웍 기능들을 사용함
![600](https://i.imgur.com/6PRgl4s.png)


### 월드(World)
---
- 게임 콘텐츠를 담기 위해 제공되는 가상의 공간
- 월드는 시간, 트랜스폼, 틱을 서비스로 제공한다
- 월드 세팅이라는 콘텐츠 제작을 위한 기본 환경 설정을 제공한다
- 월드의 기본 단위는 액터(Actor)로 정의되며, 액터 클래스는 언제나 접두사 A를 사용한다
> [!note] 월드의 역할
> - 게임 콘텐츠를 담는 공간 (Transform
> - 게임 콘텐츠의 진행 (Tick)
> - 게임 흐름을 위한 시간 (Time)
> - 기본 환경 설정 (World Setting)
> - 월드의 단위 구성 요소 (Actor)


### 게임모드(Game Mode)
---
- 게임 규칙을 지정하고 게임을 판정하는 최고 관리자 액터. → 형태가 없다.
- 언리얼 엔진에서 하나의 게임에는 반드시 하나의 게임 모드만 존재한다.
- 게임 모드에서 입장할 사용자의 규격을 지정할 수 있음.
- 멀티 플레이어 게임에서 판정을 처리하는 절대적 권위의 심판
> [!note] 게임 모드의 역할 
> - 플레이어 입장 관리
> - 게임의 최종 승패 관리
> - 게임의 규칙 관리 
> - 게임 데이터 검증 (멀티플레이 게임)


### 기믹(Gimmick)
---
- 게임 진행을 위한 이벤트를 발생시키는 사물 액터
- 주로 이벤트 발생을 위한 충돌 영역을 설정하는데, 이를 트리거(Trigger)라고 한다.
- 트리거를 통해 캐릭터와 상호 작용하고, 월드에 액터를 스폰해 콘텐츠를 전개한다.
> [!note] 기믹의 역할
> - 월드 내 사물과 상호작용을 수행
> - 지정된 조건을 만족하면 이벤트를 발생
> - 월드에 물체를 스폰(Spawn시킬 수 있음


### 플레이어(Player)
---
- 게임에 입장한 사용자 액터 → 형태가 없다.
- 게임 모드의 로그인을 통해 사용자가 게임 월드에 입장하면 플레이어가 생성된다.
- 싱글 플레이 게임에는 0번 플레이어가 설정된다.
- 사용자와의 최종 커뮤니케이션을 담당한다 *(예) 입력장치의 해석, 화면 장치로의 출력)*
> [!note] 플레이어의 역할
> - 게임에 입장한 사용자와의 1:1 대응
> - 사용자의 현재 상태 및 데이터를 관리
> - 사용자 입력의 1차 처리 (필요시)
> - 사용자 화면에 대응하는 카메라 관리
> - 사용자 화면에 나타나는 HUD UI 관리



### 폰(Pawn)
---
- 무형의 액터인 플레이어가 빙의해 조종하는 액터
- 길찾기를 사용할 수 있으며, 기믹 및 다른 폰과 상호작용한다.
- 폰 중에서 인간형 폰을 별도로 캐릭터라고 지칭한다.
> [!note] 폰의 역할
> 빙의(Process)를 통해 플레이어와 연결
> 사용자 입력의 실제 처리
> 사용자 화면에 대응되는 카메라 설정
> 기믹과의 상호작용
> 현재 상태에 적합한 애니메이션 재생



## 최종 예제에서 확장할 내용
---
- 가급적 블루프린트를 사용하지 않고 C++로만 제작
	- 이후에 블루프린트로 확장 가능
- 기본 템플릿을 사용하지 않고 직접 제작
- 두 가지의 카메라 모드를 제공 *(숄더뷰, 탑뷰)*
- 액션 입력을 통한 콤보 공격의 구현
- 아이템 에셋을 활용한 무기 상자의 구현
- NPC레벨 정보를 스프레드시트로 관리
- 플레이어와 전투하는 NPC인공지능의 구현
- UI 연동과 게임 마무리 


## 프로젝트 소스코드 폴더 규칙
---
- 게임플레이를 구성하는 요소별로 폴더를 제작해 관리
	- **Game: 게임모드와 게임 설정에 관련된 클래스 ⇒ 이번 강의에서 생성**
	- Gimmick: 기믹 배경 물체에 관련된 클래스
	- **Player: 플레이어에 관련된 클래스 ⇒ 이번 강의에서 생성**
	- Input: 플레이어 입력에 관련된 클래스
	- **Character: 기본 캐릭터와 PC 및 NPC에 관련된 클래스 ⇒ 이번 강의에서 생성**
	- Action: 캐릭터 액션에 관련된 클래스
	- Item: 캐릭터 아이템에 관련된 클래스
	- Stat: 캐릭터 스탯에 관련된 클래스
	- AI: NPC 인공지능에 관련된 클래스
	- UI: UI에 관련된 클래스
	- Physics: 물리 충돌체 설정에 관련된 전처리기
	- Iterface: 인터페이스 클래스를 모아둔 폴더 


## 클래스 생성 규칙
---
- 모든 클래스는 AB(ArenaBattle의 약자)의 접두사로 시작함
- 폴더마다 다른폴더와의 의존성을 최소화
- 다른 폴더의 클래스에 접근할 때 가급적 인터페이스를 통해 접근
- 헤더 경로를 찾기 쉽도록 `모듈.Build.cs`파일에 모듈의 폴더를 인클루드 경로에 설정
	- `PublicIncludePaths.AddRange(new string[] {"모듈이름"});` 추가

==가급적이면 다른 폴더의 헤더를 직접 참조하지 않도록 구성하는것이 바람직==


# 이번 강의에서 기억할 내용
---
## 에디터 - 월드 구성
---
- PlayerStart액터를 월드에 갖다놓을때 Z축을 충분히 위로 끌어올려준 뒤 **End**키를 누르면 바닥에 딱 붙는다.
- 레벨에대한 디폴트 클래스들(게임모드, 디폴트 폰, HUD)을 지정하는 곳은
	- `Outliner`뷰에서 `{레벨이름}(Editor)`오브젝트를 우클릭 후 `World Settings`를 클릭하면 나오는 `World Settings`뷰에 있다.

## 에디터 - 클래스 구성
---
- GameModeBase를 상속받는 클래스를 만든 뒤 에디터 컴파일에서 에러가 나면 `클래스 생성 규칙`내용에 적은대로
	- `모둘.build.cs`파일에 `PublicIncludePaths.AddRange(new string[] {"모듈이름"});`을 추가주고 다시 컴파일하면 된다/


## C++ 코드
---
- 에셋의 주소로부터 클래스 타입을 참조할 때
	- `Content Broswer`뷰에서 에셋 우클릭→Copy Reference로 주소를 복사한 뒤
	- 블루프린트라면 끝에 \_C를 붙이고 이렇게 참조
```cpp
static ConstructorHelpers::FClassFinder<APawn> ThirdPersonClassRef(TEXT("/Game/ThirdPerson/Blueprints/BP_ThirdPersonCharacter.BP_ThirdPersonCharacter_C"));
```
- 플레이 시작 시 마우스 포인터 숨기기
```cpp
void AABPlayerController::BeginPlay()
{
	Super::BeginPlay();

	// 마우스 포인터 숨기기
	FInputModeGameOnly GameOnlyInputMode;
	SetInputMode(GameOnlyInputMode);
}
```
